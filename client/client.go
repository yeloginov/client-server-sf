// Учебная программа для отработки взаимодействия Сервера и Клиента из модуля 35 SkillFactory
//
// Разработайте сетевую службу по аналогии с сервером времени, которая бы каждому
// подключившемуся клиенту показывала раз в 3 секунды случайную Go-поговорку. Поговорки возьмите с сайта.
//
// Клиентское приложение
//
// Егор Логинов, GO-11, SF, Модуль 35.8.1
package main

import (
	"bufio"
	"fmt"
	"log"
	"net"
	"time"
)

func main() {
	// Подключение к сетевой службе.
	conn, err := net.Dial("tcp4", "localhost:12345")
	if err != nil {
		log.Fatal(err)
	}
	// Не забываем закрыть ресурс.
	defer conn.Close()

	fmt.Print("Привет! Читайте поговорки Go ;) ")

	// Канал синхронизации завершения работы горутин
	exit := make(chan int)

	var s string
	// Сделаем способ выхода клиента: хотя сервер по условию задачи и не может закрыть соединение,
	// но его может закрыть клиент )
	go func() {
		for {
			fmt.Println("Вы можете ввести \"q\" для завершения...")
			_, err := fmt.Scanln(&s)
			if err != nil {
				fmt.Println(err)
			}
			// Обработка выхода
			if s == "q" {
				// Сообщаем основной петле, что пришла команда на выход
				close(exit)
				break
			}
		}
	}()

	// Буфер для чтения данных из соединения (более удобный, на основе bufio).
	reader := bufio.NewReader(conn)

	// Петля активного подключения к серверу
	for {
		// Создаем таймер для дифференцированного обращения к ридеру
		t := time.NewTimer(time.Millisecond * time.Duration(1))
		select {
		// При срабатывании таймера выводим пословицу на экран
		case <-t.C:
			{
				// Считывание массива байт.
				b, err := reader.ReadBytes('\n')
				if err != nil {
					log.Fatal(err)
				}
				// Если пришла поговрка, выводим в консоль
				if len(b) > 0 {
					fmt.Print(string(b))
				}
			}
		case <-exit:
			{
				// Сообщим серверу, что этот клиент отвалился
				_, err = conn.Write([]byte("finished\n"))
				// Прощаемся...
				fmt.Println("Понравились поговорки? Пока!")
				// И выходим
				return
			}
		}
	}
}
